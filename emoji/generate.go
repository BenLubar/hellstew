// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"sort"
	"strconv"
	"strings"
)

type emoji struct {
	Emoji       string   `json:"emoji"`
	Description string   `json:"description"`
	Category    string   `json:"category"`
	Aliases     []string `json:"aliases"`
	Tags        []string `json:"tags"`

	// not included in struct: unicode_version, ios_version
}

func main() {
	allEmoji, newETag := loadEmoji()
	if allEmoji == nil && newETag == "" {
		return
	}

	buf := []byte("// THIS FILE IS GENERATED BY generate.go\n//go:generate go run generate.go generate_etag.go\n\npackage emoji\n\ntype emoji struct {\n\temoji       string\n\tdescription string\n\taliases     []string\n}\n\nvar allEmoji = [...]emoji{\n")
	byCategory := make(map[string][]int)
	byTag := make(map[string][]int)
	var byName [][]string
	var allNames []string
	i := 0
	for _, e := range allEmoji {
		if e.Emoji == "" {
			// skip non-Unicode emoji
			continue
		}

		names := make([]string, 1, len(e.Aliases)+1)
		names[0] = e.Emoji
		for _, a := range e.Aliases {
			names = append(names, ":"+a+":")
		}
		byName = append(byName, names)
		allNames = append(allNames, names...)

		buf = append(buf, "\t{\n\t\temoji:       "...)
		buf = strconv.AppendQuote(buf, e.Emoji)
		buf = append(buf, ",\n\t\tdescription: "...)
		buf = strconv.AppendQuote(buf, e.Description)
		buf = appendAliases(buf, e.Aliases)
		buf = append(buf, ",\n\t},\n"...)

		byCategory[e.Category] = append(byCategory[e.Category], i)
		for _, t := range e.Tags {
			byTag[t] = append(byTag[t], i)
		}
		i++
	}
	buf = append(buf, "}\n"...)
	buf = appendBy(buf, "categories", "byCategory", byCategory)
	buf = appendBy(buf, "tags", "byTag", byTag)
	buf = appendStateMachine(buf, allNames)
	buf = appendNames(buf, byName)

	buf, err := format.Source(buf)
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile("emoji_data.go", buf, 0644)
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile("generate_etag.go", []byte(fmt.Sprintf("// THIS FILE IS GENERATED BY generate.go\n\n// +build ignore\n\npackage main\n\nconst etag = %q\n", newETag)), 0644)
	if err != nil {
		panic(err)
	}
}

func loadEmoji() (allEmoji []emoji, newETag string) {
	req, err := http.NewRequest("GET", "https://raw.githubusercontent.com/github/gemoji/master/db/emoji.json", nil)
	if err != nil {
		panic(err)
	}

	req.Header.Set("User-Agent", "hellstew-updater/1.0 (+https://github.com/BenLubar/hellstew)")
	req.Header.Set("If-None-Match", etag)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		panic(err)
	}
	defer func() {
		err := resp.Body.Close()
		if err != nil {
			panic(err)
		}
	}()

	if resp.StatusCode == http.StatusNotModified {
		return
	}

	if resp.StatusCode != http.StatusOK {
		panic("GET emoji.json: " + resp.Status)
	}

	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(b, &allEmoji)
	if err != nil {
		panic(err)
	}

	newETag = resp.Header.Get("ETag")

	return
}

func appendAliases(buf []byte, aliases []string) []byte {
	if len(aliases) != 0 {
		buf = append(buf, ",\n\t\taliases: []string{\n"...)
		for _, a := range aliases {
			buf = append(buf, "\t\t\t"...)
			buf = strconv.AppendQuote(buf, a)
			buf = append(buf, ",\n"...)
		}
		buf = append(buf, "\t\t}"...)
	}
	return buf
}

func appendBy(buf []byte, stringVar, byVar string, by map[string][]int) []byte {
	buf = append(buf, "\nvar "...)
	buf = append(buf, stringVar...)
	buf = append(buf, " = []string{\n"...)
	str := make([]string, 0, len(by))
	for s := range by {
		str = append(str, s)
	}
	sort.Strings(str)
	for _, s := range str {
		buf = append(buf, "\t"...)
		buf = strconv.AppendQuote(buf, s)
		buf = append(buf, ",\n"...)
	}
	buf = append(buf, "}\n\nvar "...)
	buf = append(buf, byVar...)
	buf = append(buf, " = [][]*emoji{\n"...)
	for _, s := range str {
		buf = append(buf, "\t// "...)
		buf = append(buf, s...)
		buf = append(buf, "\n\t{\n"...)
		for _, idx := range by[s] {
			buf = append(buf, "\t\t&allEmoji["...)
			buf = strconv.AppendInt(buf, int64(idx), 10)
			buf = append(buf, "],\n"...)
		}
		buf = append(buf, "\t},\n"...)
	}
	buf = append(buf, "}\n"...)
	return buf
}

func appendStateMachine(buf []byte, allNames []string) []byte {
	for i, s := range allNames {
		allNames[i] = strings.ToLower(s)
	}
	sort.Strings(allNames)
	buf = append(buf, "\ntype state struct {\n\tnext [256]*state\n\tterm bool\n}\n\nvar startState = "...)
	buf = appendState(buf, "", "", allNames)
	buf = append(buf, "\n"...)
	return buf
}

func appendState(buf []byte, indent, prefix string, names []string) []byte {
	buf = append(buf, indent...)
	buf = append(buf, "&state{\n"...)

	if names[0] == prefix {
		buf = append(buf, indent...)
		buf = append(buf, "\tterm: true, // "...)
		buf = strconv.AppendQuote(buf, names[0])
		buf = append(buf, "\n"...)
		names = names[1:]
	}

	if len(names) != 0 {
		nextIndent := indent + "\t\t"
		buf = append(buf, indent...)
		buf = append(buf, "\tnext: [256]*state{\n"...)
		for len(names) != 0 {
			b := names[0][len(prefix)]
			end := sort.Search(len(names), func(i int) bool {
				return names[i][len(prefix)] > b
			})
			buf = strconv.AppendUint(buf, uint64(b), 10)
			buf = append(buf, ": "...)
			buf = appendState(buf, nextIndent, names[0][:len(prefix)+1], names[:end])
			buf = append(buf, ",\n"...)
			names = names[end:]
		}
		buf = append(buf, indent...)
		buf = append(buf, "\t},\n"...)
	}

	buf = append(buf, indent...)
	buf = append(buf, "}"...)

	return buf
}

func appendNames(buf []byte, byName [][]string) []byte {
	buf = append(buf, "\nvar byName = map[string]*emoji{\n"...)
	for idx, names := range byName {
		for _, name := range names {
			buf = append(buf, "\t"...)
			buf = strconv.AppendQuote(buf, name)
			buf = append(buf, ": &allEmoji["...)
			buf = strconv.AppendInt(buf, int64(idx), 10)
			buf = append(buf, "],\n"...)
		}
	}
	buf = append(buf, "}\n"...)
	return buf
}
