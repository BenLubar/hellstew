// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"go/format"
	"io/ioutil"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

type emoji struct {
	Emoji       string   `json:"emoji"`
	Description string   `json:"description"`
	Category    string   `json:"category"`
	Aliases     []string `json:"aliases"`
	Tags        []string `json:"tags"`

	// not included in struct: unicode_version, ios_version
}

func main() {
	allEmoji, newETag := loadEmoji()
	if allEmoji == nil && newETag == "" {
		return
	}

	buf := []byte("// THIS FILE IS GENERATED BY generate.go\n//go:generate go run generate.go generate_etag.go\n\npackage emoji\n\nimport \"regexp\"\n\ntype emoji struct {\n\temoji       string\n\tdescription string\n\taliases     []string\n}\n\nvar allEmoji = [...]emoji{\n")
	byCategory := make(map[string][]int)
	byTag := make(map[string][]int)
	var byName [][]string
	var allNames []string
	i := 0
	for _, e := range allEmoji {
		if e.Emoji == "" {
			// skip non-Unicode emoji
			continue
		}

		names := make([]string, 1, len(e.Aliases)+1)
		names[0] = e.Emoji
		for _, a := range e.Aliases {
			names = append(names, ":"+a+":")
		}
		byName = append(byName, names)
		allNames = append(allNames, names...)

		buf = append(buf, "\t{\n\t\temoji:       "...)
		buf = strconv.AppendQuote(buf, e.Emoji)
		buf = append(buf, ",\n\t\tdescription: "...)
		buf = strconv.AppendQuote(buf, e.Description)
		buf = appendAliases(buf, e.Aliases)
		buf = append(buf, ",\n\t},\n"...)

		byCategory[e.Category] = append(byCategory[e.Category], i)
		for _, t := range e.Tags {
			byTag[t] = append(byTag[t], i)
		}
		i++
	}
	buf = append(buf, "}\n"...)
	buf = appendBy(buf, "categories", "byCategory", byCategory)
	buf = appendBy(buf, "tags", "byTag", byTag)
	buf = appendRegexp(buf, allNames)
	buf = appendNames(buf, byName)

	buf, err := format.Source(buf)
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile("emoji_data.go", buf, 0644)
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile("generate_etag.go", []byte(fmt.Sprintf("// THIS FILE IS GENERATED BY generate.go\n\n// +build ignore\n\npackage main\n\nconst etag = %q\n", newETag)), 0644)
	if err != nil {
		panic(err)
	}
}

func loadEmoji() (allEmoji []emoji, newETag string) {
	req, err := http.NewRequest("GET", "https://raw.githubusercontent.com/github/gemoji/master/db/emoji.json", nil)
	if err != nil {
		panic(err)
	}

	req.Header.Set("User-Agent", "hellstew-updater/1.0 (+https://github.com/BenLubar/hellstew)")
	req.Header.Set("If-None-Match", etag)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		panic(err)
	}
	defer func() {
		err := resp.Body.Close()
		if err != nil {
			panic(err)
		}
	}()

	if resp.StatusCode == http.StatusNotModified {
		return
	}

	if resp.StatusCode != http.StatusOK {
		panic("GET emoji.json: " + resp.Status)
	}

	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(b, &allEmoji)
	if err != nil {
		panic(err)
	}

	newETag = resp.Header.Get("ETag")

	return
}

func appendAliases(buf []byte, aliases []string) []byte {
	if len(aliases) != 0 {
		buf = append(buf, ",\n\t\taliases: []string{\n"...)
		for _, a := range aliases {
			buf = append(buf, "\t\t\t"...)
			buf = strconv.AppendQuote(buf, a)
			buf = append(buf, ",\n"...)
		}
		buf = append(buf, "\t\t}"...)
	}
	return buf
}

func appendBy(buf []byte, stringVar, byVar string, by map[string][]int) []byte {
	buf = append(buf, "\nvar "...)
	buf = append(buf, stringVar...)
	buf = append(buf, " = []string{\n"...)
	str := make([]string, 0, len(by))
	for s := range by {
		str = append(str, s)
	}
	sort.Strings(str)
	for _, s := range str {
		buf = append(buf, "\t"...)
		buf = strconv.AppendQuote(buf, s)
		buf = append(buf, ",\n"...)
	}
	buf = append(buf, "}\n\nvar "...)
	buf = append(buf, byVar...)
	buf = append(buf, " = [][]*emoji{\n"...)
	for _, s := range str {
		buf = append(buf, "\t// "...)
		buf = append(buf, s...)
		buf = append(buf, "\n\t{\n"...)
		for _, idx := range by[s] {
			buf = append(buf, "\t\t&allEmoji["...)
			buf = strconv.AppendInt(buf, int64(idx), 10)
			buf = append(buf, "],\n"...)
		}
		buf = append(buf, "\t},\n"...)
	}
	buf = append(buf, "}\n"...)
	return buf
}

func appendRegexp(buf []byte, allNames []string) []byte {
	buf = append(buf, "\nvar re = regexp.MustCompile("...)
	for i, name := range allNames {
		allNames[i] = regexp.QuoteMeta(name)
	}
	buf = strconv.AppendQuote(buf, "("+strings.Join(allNames, "|")+")")
	buf = append(buf, ")\n\nfunc init() {\n\tre.Longest()\n}\n"...)
	return buf
}

func appendNames(buf []byte, byName [][]string) []byte {
	buf = append(buf, "\nvar byName = map[string]*emoji{\n"...)
	for idx, names := range byName {
		for _, name := range names {
			buf = append(buf, "\t"...)
			buf = strconv.AppendQuote(buf, name)
			buf = append(buf, ": &allEmoji["...)
			buf = strconv.AppendInt(buf, int64(idx), 10)
			buf = append(buf, "],\n"...)
		}
	}
	buf = append(buf, "}\n"...)
	return buf
}
